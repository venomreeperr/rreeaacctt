import{DataTextureLoader as Me,HalfFloatType as K,FloatType as oe,DataUtils as X,LinearFilter as ce}from"three";var ie=class extends Me{constructor(e){super(e),this.type=K}parse(e){let a=function(n,m){switch(n){case 1:throw new Error("THREE.RGBELoader: Read Error: "+(m||""));case 2:throw new Error("THREE.RGBELoader: Write Error: "+(m||""));case 3:throw new Error("THREE.RGBELoader: Bad File Format: "+(m||""));default:case 4:throw new Error("THREE.RGBELoader: Memory Error: "+(m||""))}},b=`
`,L=function(n,m,l){m=m||1024;let u=n.pos,c=-1,s=0,h="",p=String.fromCharCode.apply(null,new Uint16Array(n.subarray(u,u+128)));for(;0>(c=p.indexOf(b))&&s<m&&u<n.byteLength;)h+=p,s+=p.length,u+=128,p+=String.fromCharCode.apply(null,new Uint16Array(n.subarray(u,u+128)));return-1<c?(l!==!1&&(n.pos+=s+c+1),h+p.slice(0,c)):!1},C=function(n){let m=/^#\?(\S+)/,l=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,d=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,u=/^\s*FORMAT=(\S+)\s*$/,c=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,s={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0},h,p;for((n.pos>=n.byteLength||!(h=L(n)))&&a(1,"no header found"),(p=h.match(m))||a(3,"bad initial token"),s.valid|=1,s.programtype=p[1],s.string+=h+`
`;h=L(n),h!==!1;){if(s.string+=h+`
`,h.charAt(0)==="#"){s.comments+=h+`
`;continue}if((p=h.match(l))&&(s.gamma=parseFloat(p[1])),(p=h.match(d))&&(s.exposure=parseFloat(p[1])),(p=h.match(u))&&(s.valid|=2,s.format=p[1]),(p=h.match(c))&&(s.valid|=4,s.height=parseInt(p[1],10),s.width=parseInt(p[2],10)),s.valid&2&&s.valid&4)break}return s.valid&2||a(3,"missing format specifier"),s.valid&4||a(3,"missing image size specifier"),s},ee=function(n,m,l){let d=m;if(d<8||d>32767||n[0]!==2||n[1]!==2||n[2]&128)return new Uint8Array(n);d!==(n[2]<<8|n[3])&&a(3,"wrong scanline width");let u=new Uint8Array(4*m*l);u.length||a(4,"unable to allocate buffer space");let c=0,s=0,h=4*d,p=new Uint8Array(4),z=new Uint8Array(h),pe=l;for(;pe>0&&s<n.byteLength;){s+4>n.byteLength&&a(1),p[0]=n[s++],p[1]=n[s++],p[2]=n[s++],p[3]=n[s++],(p[0]!=2||p[1]!=2||(p[2]<<8|p[3])!=d)&&a(3,"bad rgbe scanline format");let V=0,R;for(;V<h&&s<n.byteLength;){R=n[s++];let T=R>128;if(T&&(R-=128),(R===0||V+R>h)&&a(3,"bad scanline data"),T){let D=n[s++];for(let de=0;de<R;de++)z[V++]=D}else z.set(n.subarray(s,s+R),V),V+=R,s+=R}let Ee=d;for(let T=0;T<Ee;T++){let D=0;u[c]=z[T+D],D+=d,u[c+1]=z[T+D],D+=d,u[c+2]=z[T+D],D+=d,u[c+3]=z[T+D],c+=4}pe--}return u},le=function(n,m,l,d){let u=n[m+3],c=Math.pow(2,u-128)/255;l[d+0]=n[m+0]*c,l[d+1]=n[m+1]*c,l[d+2]=n[m+2]*c,l[d+3]=1},k=function(n,m,l,d){let u=n[m+3],c=Math.pow(2,u-128)/255;l[d+0]=X.toHalfFloat(Math.min(n[m+0]*c,65504)),l[d+1]=X.toHalfFloat(Math.min(n[m+1]*c,65504)),l[d+2]=X.toHalfFloat(Math.min(n[m+2]*c,65504)),l[d+3]=X.toHalfFloat(1)},U=new Uint8Array(e);U.pos=0;let G=C(U),j=G.width,B=G.height,_=ee(U.subarray(U.pos),j,B),te,re,F;switch(this.type){case oe:F=_.length/4;let n=new Float32Array(F*4);for(let l=0;l<F;l++)le(_,l*4,n,l*4);te=n,re=oe;break;case K:F=_.length/4;let m=new Uint16Array(F*4);for(let l=0;l<F;l++)k(_,l*4,m,l*4);te=m,re=K;break;default:throw new Error("THREE.RGBELoader: Unsupported type: "+this.type)}return{width:j,height:B,data:te,header:G.string,gamma:G.gamma,exposure:G.exposure,type:re}}setDataType(e){return this.type=e,this}load(e,t,i,r){function o(a,f){switch(a.type){case oe:case K:"colorSpace"in a?a.colorSpace="srgb-linear":a.encoding=3e3,a.minFilter=ce,a.magFilter=ce,a.generateMipmaps=!1,a.flipY=!0;break}t&&t(a,f)}return super.load(e,o,i,r)}};import{InstancedBufferGeometry as Ae,Float32BufferAttribute as ue,InstancedInterleavedBuffer as he,InterleavedBufferAttribute as q,WireframeGeometry as Ce,Box3 as ge,Sphere as Be,Vector3 as Re}from"three";var Se=new ge,Y=new Re,I=class extends Ae{constructor(){super(),this.isLineSegmentsGeometry=!0,this.type="LineSegmentsGeometry";let e=[-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],t=[-1,2,1,2,-1,1,1,1,-1,-1,1,-1,-1,-2,1,-2],i=[0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5];this.setIndex(i),this.setAttribute("position",new ue(e,3)),this.setAttribute("uv",new ue(t,2))}applyMatrix4(e){let t=this.attributes.instanceStart,i=this.attributes.instanceEnd;return t!==void 0&&(t.applyMatrix4(e),i.applyMatrix4(e),t.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}setPositions(e){let t;e instanceof Float32Array?t=e:Array.isArray(e)&&(t=new Float32Array(e));let i=new he(t,6,1);return this.setAttribute("instanceStart",new q(i,3,0)),this.setAttribute("instanceEnd",new q(i,3,3)),this.computeBoundingBox(),this.computeBoundingSphere(),this}setColors(e,t=3){let i;e instanceof Float32Array?i=e:Array.isArray(e)&&(i=new Float32Array(e));let r=new he(i,t*2,1);return this.setAttribute("instanceColorStart",new q(r,t,0)),this.setAttribute("instanceColorEnd",new q(r,t,t)),this}fromWireframeGeometry(e){return this.setPositions(e.attributes.position.array),this}fromEdgesGeometry(e){return this.setPositions(e.attributes.position.array),this}fromMesh(e){return this.fromWireframeGeometry(new Ce(e.geometry)),this}fromLineSegments(e){let t=e.geometry;return this.setPositions(t.attributes.position.array),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new ge);let e=this.attributes.instanceStart,t=this.attributes.instanceEnd;e!==void 0&&t!==void 0&&(this.boundingBox.setFromBufferAttribute(e),Se.setFromBufferAttribute(t),this.boundingBox.union(Se))}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Be),this.boundingBox===null&&this.computeBoundingBox();let e=this.attributes.instanceStart,t=this.attributes.instanceEnd;if(e!==void 0&&t!==void 0){let i=this.boundingSphere.center;this.boundingBox.getCenter(i);let r=0;for(let o=0,a=e.count;o<a;o++)Y.fromBufferAttribute(e,o),r=Math.max(r,i.distanceToSquared(Y)),Y.fromBufferAttribute(t,o),r=Math.max(r,i.distanceToSquared(Y));this.boundingSphere.radius=Math.sqrt(r),isNaN(this.boundingSphere.radius)&&console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",this)}}toJSON(){}applyMatrix(e){return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."),this.applyMatrix4(e)}};var N=class extends I{constructor(){super(),this.isLineGeometry=!0,this.type="LineGeometry"}setPositions(e){let t=e.length-3,i=new Float32Array(2*t);for(let r=0;r<t;r+=3)i[2*r]=e[r],i[2*r+1]=e[r+1],i[2*r+2]=e[r+2],i[2*r+3]=e[r+3],i[2*r+4]=e[r+4],i[2*r+5]=e[r+5];return super.setPositions(i),this}setColors(e,t=3){let i=e.length-t,r=new Float32Array(2*i);if(t===3)for(let o=0;o<i;o+=t)r[2*o]=e[o],r[2*o+1]=e[o+1],r[2*o+2]=e[o+2],r[2*o+3]=e[o+3],r[2*o+4]=e[o+4],r[2*o+5]=e[o+5];else for(let o=0;o<i;o+=t)r[2*o]=e[o],r[2*o+1]=e[o+1],r[2*o+2]=e[o+2],r[2*o+3]=e[o+3],r[2*o+4]=e[o+4],r[2*o+5]=e[o+5],r[2*o+6]=e[o+6],r[2*o+7]=e[o+7];return super.setColors(r,t),this}fromLine(e){let t=e.geometry;return this.setPositions(t.attributes.position.array),this}};import{ShaderMaterial as De,UniformsUtils as ve,UniformsLib as ye,Vector2 as Pe}from"three";import{REVISION as Te}from"three";var $=parseInt(Te.replace(/\D+/g,""));var O=class extends De{constructor(e){super({type:"LineMaterial",uniforms:ve.clone(ve.merge([ye.common,ye.fog,{worldUnits:{value:1},linewidth:{value:1},resolution:{value:new Pe(1,1)},dashOffset:{value:0},dashScale:{value:1},dashSize:{value:1},gapSize:{value:1}}])),vertexShader:`
				#include <common>
				#include <fog_pars_vertex>
				#include <logdepthbuf_pars_vertex>
				#include <clipping_planes_pars_vertex>

				uniform float linewidth;
				uniform vec2 resolution;

				attribute vec3 instanceStart;
				attribute vec3 instanceEnd;

				#ifdef USE_COLOR
					#ifdef USE_LINE_COLOR_ALPHA
						varying vec4 vLineColor;
						attribute vec4 instanceColorStart;
						attribute vec4 instanceColorEnd;
					#else
						varying vec3 vLineColor;
						attribute vec3 instanceColorStart;
						attribute vec3 instanceColorEnd;
					#endif
				#endif

				#ifdef WORLD_UNITS

					varying vec4 worldPos;
					varying vec3 worldStart;
					varying vec3 worldEnd;

					#ifdef USE_DASH

						varying vec2 vUv;

					#endif

				#else

					varying vec2 vUv;

				#endif

				#ifdef USE_DASH

					uniform float dashScale;
					attribute float instanceDistanceStart;
					attribute float instanceDistanceEnd;
					varying float vLineDistance;

				#endif

				void trimSegment( const in vec4 start, inout vec4 end ) {

					// trim end segment so it terminates between the camera plane and the near plane

					// conservative estimate of the near plane
					float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
					float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
					float nearEstimate = - 0.5 * b / a;

					float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

					end.xyz = mix( start.xyz, end.xyz, alpha );

				}

				void main() {

					#ifdef USE_COLOR

						vLineColor = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

					#endif

					#ifdef USE_DASH

						vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
						vUv = uv;

					#endif

					float aspect = resolution.x / resolution.y;

					// camera space
					vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
					vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

					#ifdef WORLD_UNITS

						worldStart = start.xyz;
						worldEnd = end.xyz;

					#else

						vUv = uv;

					#endif

					// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
					// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
					// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
					// perhaps there is a more elegant solution -- WestLangley

					bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

					if ( perspective ) {

						if ( start.z < 0.0 && end.z >= 0.0 ) {

							trimSegment( start, end );

						} else if ( end.z < 0.0 && start.z >= 0.0 ) {

							trimSegment( end, start );

						}

					}

					// clip space
					vec4 clipStart = projectionMatrix * start;
					vec4 clipEnd = projectionMatrix * end;

					// ndc space
					vec3 ndcStart = clipStart.xyz / clipStart.w;
					vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

					// direction
					vec2 dir = ndcEnd.xy - ndcStart.xy;

					// account for clip-space aspect ratio
					dir.x *= aspect;
					dir = normalize( dir );

					#ifdef WORLD_UNITS

						// get the offset direction as perpendicular to the view vector
						vec3 worldDir = normalize( end.xyz - start.xyz );
						vec3 offset;
						if ( position.y < 0.5 ) {

							offset = normalize( cross( start.xyz, worldDir ) );

						} else {

							offset = normalize( cross( end.xyz, worldDir ) );

						}

						// sign flip
						if ( position.x < 0.0 ) offset *= - 1.0;

						float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

						// don't extend the line if we're rendering dashes because we
						// won't be rendering the endcaps
						#ifndef USE_DASH

							// extend the line bounds to encompass  endcaps
							start.xyz += - worldDir * linewidth * 0.5;
							end.xyz += worldDir * linewidth * 0.5;

							// shift the position of the quad so it hugs the forward edge of the line
							offset.xy -= dir * forwardOffset;
							offset.z += 0.5;

						#endif

						// endcaps
						if ( position.y > 1.0 || position.y < 0.0 ) {

							offset.xy += dir * 2.0 * forwardOffset;

						}

						// adjust for linewidth
						offset *= linewidth * 0.5;

						// set the world position
						worldPos = ( position.y < 0.5 ) ? start : end;
						worldPos.xyz += offset;

						// project the worldpos
						vec4 clip = projectionMatrix * worldPos;

						// shift the depth of the projected points so the line
						// segments overlap neatly
						vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
						clip.z = clipPose.z * clip.w;

					#else

						vec2 offset = vec2( dir.y, - dir.x );
						// undo aspect ratio adjustment
						dir.x /= aspect;
						offset.x /= aspect;

						// sign flip
						if ( position.x < 0.0 ) offset *= - 1.0;

						// endcaps
						if ( position.y < 0.0 ) {

							offset += - dir;

						} else if ( position.y > 1.0 ) {

							offset += dir;

						}

						// adjust for linewidth
						offset *= linewidth;

						// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
						offset /= resolution.y;

						// select end
						vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

						// back to clip space
						offset *= clip.w;

						clip.xy += offset;

					#endif

					gl_Position = clip;

					vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

					#include <logdepthbuf_vertex>
					#include <clipping_planes_vertex>
					#include <fog_vertex>

				}
			`,fragmentShader:`
				uniform vec3 diffuse;
				uniform float opacity;
				uniform float linewidth;

				#ifdef USE_DASH

					uniform float dashOffset;
					uniform float dashSize;
					uniform float gapSize;

				#endif

				varying float vLineDistance;

				#ifdef WORLD_UNITS

					varying vec4 worldPos;
					varying vec3 worldStart;
					varying vec3 worldEnd;

					#ifdef USE_DASH

						varying vec2 vUv;

					#endif

				#else

					varying vec2 vUv;

				#endif

				#include <common>
				#include <fog_pars_fragment>
				#include <logdepthbuf_pars_fragment>
				#include <clipping_planes_pars_fragment>

				#ifdef USE_COLOR
					#ifdef USE_LINE_COLOR_ALPHA
						varying vec4 vLineColor;
					#else
						varying vec3 vLineColor;
					#endif
				#endif

				vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

					float mua;
					float mub;

					vec3 p13 = p1 - p3;
					vec3 p43 = p4 - p3;

					vec3 p21 = p2 - p1;

					float d1343 = dot( p13, p43 );
					float d4321 = dot( p43, p21 );
					float d1321 = dot( p13, p21 );
					float d4343 = dot( p43, p43 );
					float d2121 = dot( p21, p21 );

					float denom = d2121 * d4343 - d4321 * d4321;

					float numer = d1343 * d4321 - d1321 * d4343;

					mua = numer / denom;
					mua = clamp( mua, 0.0, 1.0 );
					mub = ( d1343 + d4321 * ( mua ) ) / d4343;
					mub = clamp( mub, 0.0, 1.0 );

					return vec2( mua, mub );

				}

				void main() {

					#include <clipping_planes_fragment>

					#ifdef USE_DASH

						if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

						if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

					#endif

					float alpha = opacity;

					#ifdef WORLD_UNITS

						// Find the closest points on the view ray and the line segment
						vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
						vec3 lineDir = worldEnd - worldStart;
						vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

						vec3 p1 = worldStart + lineDir * params.x;
						vec3 p2 = rayEnd * params.y;
						vec3 delta = p1 - p2;
						float len = length( delta );
						float norm = len / linewidth;

						#ifndef USE_DASH

							#ifdef USE_ALPHA_TO_COVERAGE

								float dnorm = fwidth( norm );
								alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

							#else

								if ( norm > 0.5 ) {

									discard;

								}

							#endif

						#endif

					#else

						#ifdef USE_ALPHA_TO_COVERAGE

							// artifacts appear on some hardware if a derivative is taken within a conditional
							float a = vUv.x;
							float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
							float len2 = a * a + b * b;
							float dlen = fwidth( len2 );

							if ( abs( vUv.y ) > 1.0 ) {

								alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

							}

						#else

							if ( abs( vUv.y ) > 1.0 ) {

								float a = vUv.x;
								float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
								float len2 = a * a + b * b;

								if ( len2 > 1.0 ) discard;

							}

						#endif

					#endif

					vec4 diffuseColor = vec4( diffuse, alpha );
					#ifdef USE_COLOR
						#ifdef USE_LINE_COLOR_ALPHA
							diffuseColor *= vLineColor;
						#else
							diffuseColor.rgb *= vLineColor;
						#endif
					#endif

					#include <logdepthbuf_fragment>

					gl_FragColor = diffuseColor;

					#include <tonemapping_fragment>
					#include <${$>=154?"colorspace_fragment":"encodings_fragment"}>
					#include <fog_fragment>
					#include <premultiplied_alpha_fragment>

				}
			`,clipping:!0}),this.isLineMaterial=!0,this.onBeforeCompile=function(){this.transparent?this.defines.USE_LINE_COLOR_ALPHA="1":delete this.defines.USE_LINE_COLOR_ALPHA},Object.defineProperties(this,{color:{enumerable:!0,get:function(){return this.uniforms.diffuse.value},set:function(t){this.uniforms.diffuse.value=t}},worldUnits:{enumerable:!0,get:function(){return"WORLD_UNITS"in this.defines},set:function(t){t===!0?this.defines.WORLD_UNITS="":delete this.defines.WORLD_UNITS}},linewidth:{enumerable:!0,get:function(){return this.uniforms.linewidth.value},set:function(t){this.uniforms.linewidth.value=t}},dashed:{enumerable:!0,get:function(){return"USE_DASH"in this.defines},set(t){!!t!="USE_DASH"in this.defines&&(this.needsUpdate=!0),t===!0?this.defines.USE_DASH="":delete this.defines.USE_DASH}},dashScale:{enumerable:!0,get:function(){return this.uniforms.dashScale.value},set:function(t){this.uniforms.dashScale.value=t}},dashSize:{enumerable:!0,get:function(){return this.uniforms.dashSize.value},set:function(t){this.uniforms.dashSize.value=t}},dashOffset:{enumerable:!0,get:function(){return this.uniforms.dashOffset.value},set:function(t){this.uniforms.dashOffset.value=t}},gapSize:{enumerable:!0,get:function(){return this.uniforms.gapSize.value},set:function(t){this.uniforms.gapSize.value=t}},opacity:{enumerable:!0,get:function(){return this.uniforms.opacity.value},set:function(t){this.uniforms.opacity.value=t}},resolution:{enumerable:!0,get:function(){return this.uniforms.resolution.value},set:function(t){this.uniforms.resolution.value.copy(t)}},alphaToCoverage:{enumerable:!0,get:function(){return"USE_ALPHA_TO_COVERAGE"in this.defines},set:function(t){!!t!="USE_ALPHA_TO_COVERAGE"in this.defines&&(this.needsUpdate=!0),t===!0?(this.defines.USE_ALPHA_TO_COVERAGE="",this.extensions.derivatives=!0):(delete this.defines.USE_ALPHA_TO_COVERAGE,this.extensions.derivatives=!1)}}}),this.setValues(e)}};import{Mesh as Ue,InstancedInterleavedBuffer as Ge,InterleavedBufferAttribute as Le,Vector4 as W,Vector3 as P,Box3 as Oe,Sphere as He,MathUtils as Fe,Matrix4 as ze,Line3 as Ie}from"three";var ne=$>=125?"uv1":"uv2";var ae=new W,xe=new P,be=new P,g=new W,v=new W,E=new W,se=new P,me=new ze,y=new Ie,_e=new P,J=new Oe,Z=new He,M=new W,A,H;function we(S,e,t){return M.set(0,0,-e,1).applyMatrix4(S.projectionMatrix),M.multiplyScalar(1/M.w),M.x=H/t.width,M.y=H/t.height,M.applyMatrix4(S.projectionMatrixInverse),M.multiplyScalar(1/M.w),Math.abs(Math.max(M.x,M.y))}function Ve(S,e){let t=S.matrixWorld,i=S.geometry,r=i.attributes.instanceStart,o=i.attributes.instanceEnd,a=Math.min(i.instanceCount,r.count);for(let f=0,x=a;f<x;f++){y.start.fromBufferAttribute(r,f),y.end.fromBufferAttribute(o,f),y.applyMatrix4(t);let w=new P,b=new P;A.distanceSqToSegment(y.start,y.end,b,w),b.distanceTo(w)<H*.5&&e.push({point:b,pointOnLine:w,distance:A.origin.distanceTo(b),object:S,face:null,faceIndex:f,uv:null,[ne]:null})}}function Ne(S,e,t){let i=e.projectionMatrix,o=S.material.resolution,a=S.matrixWorld,f=S.geometry,x=f.attributes.instanceStart,w=f.attributes.instanceEnd,b=Math.min(f.instanceCount,x.count),L=-e.near;A.at(1,E),E.w=1,E.applyMatrix4(e.matrixWorldInverse),E.applyMatrix4(i),E.multiplyScalar(1/E.w),E.x*=o.x/2,E.y*=o.y/2,E.z=0,se.copy(E),me.multiplyMatrices(e.matrixWorldInverse,a);for(let C=0,ee=b;C<ee;C++){if(g.fromBufferAttribute(x,C),v.fromBufferAttribute(w,C),g.w=1,v.w=1,g.applyMatrix4(me),v.applyMatrix4(me),g.z>L&&v.z>L)continue;if(g.z>L){let B=g.z-v.z,_=(g.z-L)/B;g.lerp(v,_)}else if(v.z>L){let B=v.z-g.z,_=(v.z-L)/B;v.lerp(g,_)}g.applyMatrix4(i),v.applyMatrix4(i),g.multiplyScalar(1/g.w),v.multiplyScalar(1/v.w),g.x*=o.x/2,g.y*=o.y/2,v.x*=o.x/2,v.y*=o.y/2,y.start.copy(g),y.start.z=0,y.end.copy(v),y.end.z=0;let k=y.closestPointToPointParameter(se,!0);y.at(k,_e);let U=Fe.lerp(g.z,v.z,k),G=U>=-1&&U<=1,j=se.distanceTo(_e)<H*.5;if(G&&j){y.start.fromBufferAttribute(x,C),y.end.fromBufferAttribute(w,C),y.start.applyMatrix4(a),y.end.applyMatrix4(a);let B=new P,_=new P;A.distanceSqToSegment(y.start,y.end,_,B),t.push({point:_,pointOnLine:B,distance:A.origin.distanceTo(_),object:S,face:null,faceIndex:C,uv:null,[ne]:null})}}}var Q=class extends Ue{constructor(e=new I,t=new O({color:Math.random()*16777215})){super(e,t),this.isLineSegments2=!0,this.type="LineSegments2"}computeLineDistances(){let e=this.geometry,t=e.attributes.instanceStart,i=e.attributes.instanceEnd,r=new Float32Array(2*t.count);for(let a=0,f=0,x=t.count;a<x;a++,f+=2)xe.fromBufferAttribute(t,a),be.fromBufferAttribute(i,a),r[f]=f===0?0:r[f-1],r[f+1]=r[f]+xe.distanceTo(be);let o=new Ge(r,2,1);return e.setAttribute("instanceDistanceStart",new Le(o,1,0)),e.setAttribute("instanceDistanceEnd",new Le(o,1,1)),this}raycast(e,t){let i=this.material.worldUnits,r=e.camera;r===null&&!i&&console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');let o=e.params.Line2!==void 0&&e.params.Line2.threshold||0;A=e.ray;let a=this.matrixWorld,f=this.geometry,x=this.material;H=x.linewidth+o,f.boundingSphere===null&&f.computeBoundingSphere(),Z.copy(f.boundingSphere).applyMatrix4(a);let w;if(i)w=H*.5;else{let L=Math.max(r.near,Z.distanceToPoint(A.origin));w=we(r,L,x.resolution)}if(Z.radius+=w,A.intersectsSphere(Z)===!1)return;f.boundingBox===null&&f.computeBoundingBox(),J.copy(f.boundingBox).applyMatrix4(a);let b;if(i)b=H*.5;else{let L=Math.max(r.near,J.distanceToPoint(A.origin));b=we(r,L,x.resolution)}J.expandByScalar(b),A.intersectsBox(J)!==!1&&(i?Ve(this,t):Ne(this,r,t))}onBeforeRender(e){let t=this.material.uniforms;t&&t.resolution&&(e.getViewport(ae),this.material.uniforms.resolution.value.set(ae.z,ae.w))}};var fe=class extends Q{constructor(e=new N,t=new O({color:Math.random()*16777215})){super(e,t),this.isLine2=!0,this.type="Line2"}};export{ie as a,N as b,O as c,fe as d};
